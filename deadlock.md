## LAB04_deadlock  

  
## 实验截图  
![1.png](https://ooo.0o0.ooo/2016/11/02/5819fb05512d0.png)  

## 产生死锁的4个必要条件  
1.互斥；至少有一个资源处于非共享模式  
2.占有并等待 hold and wait；一个进程必须占有一个资源并等待另一个资源，且该资源被其他线程占有  
3.cpu调度属于非强占模式；资源只能在完成任务后释放，不可强行占用  
4.等待资源的线程处于循环等待的状态  
  
  
## 产生死锁的解释  
若在同一时间，a请求b、b请求a则会发生死锁  
即a.methodA(b)里的b.last()和b.methodB(a)里的a.last()执行时间相同，彼此都在请求对方资源，就会产生死锁  
synchronized限定当一个类的一个资源被某一个线程占用，其他的资源就不可以被另外的线程申请到，在这种情况下，两个线程分别占有一个资源有申请对方所占用的资源，但是对方线程本身占用的资源必须等到申请到所需资源之后才能释放，就会产生死锁。
